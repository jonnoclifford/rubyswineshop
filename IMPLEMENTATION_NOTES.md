# Tina CMS Implementation Notes

Technical documentation covering the integration of Tina CMS into Ruby's Wine Bar website, architectural decisions, and implementation details.

## Table of Contents

1. [Overview](#overview)
2. [What Changed from Original Implementation](#what-changed-from-original-implementation)
3. [How the CMS Integration Works](#how-the-cms-integration-works)
4. [Architecture Decisions](#architecture-decisions)
5. [Migration from Static Config to Tina](#migration-from-static-config-to-tina)
6. [Technical Implementation Details](#technical-implementation-details)
7. [Future Improvements](#future-improvements)

---

## Overview

This project originally used a static TypeScript configuration file (`src/content/site-config.ts`) for all website content. Tina CMS was integrated to provide a visual editing interface while maintaining the same content structure and type safety.

### Key Integration Goals

- Provide a user-friendly CMS for non-technical users
- Maintain existing TypeScript types and data structure
- Enable local development without cloud dependency
- Keep git-based workflow for version control
- Preserve site performance and build process
- Enable visual editing with live preview

### Technology Stack

- **CMS**: Tina CMS v3.3.2
- **Framework**: Next.js 15 (App Router)
- **Language**: TypeScript
- **Deployment**: Vercel
- **Content Storage**: Git-based (file system)
- **Authentication**: Local auth for dev, Tina Cloud for production

---

## What Changed from Original Implementation

### 1. Dependencies Added

**NPM Packages**:
```json
{
  "@tinacms/cli": "^2.1.2",
  "tinacms": "^3.3.2"
}
```

### 2. Project Structure Changes

**New Files**:
- `.tina/config.ts` - Tina CMS schema configuration
- `src/lib/tina.ts` - Database client configuration
- `src/app/api/tina/[...routes]/route.ts` - API routes for Tina backend
- `src/app/admin/page.tsx` - Admin interface redirect
- `.env.example` - Updated with Tina environment variables
- `TINA_CMS_SETUP.md` - Previous setup documentation

**Modified Files**:
- `package.json` - Updated scripts and dependencies
- `.gitignore` - Added `.tina/__generated__` to ignore generated files
- `README.md` - Updated with CMS information (optionally)

**Generated at Build/Runtime**:
- `public/admin/` - Tina admin interface (generated by `tinacms build`)
- `.tina/__generated__/` - TypeScript types and GraphQL schema

### 3. Content Structure

**Before**: Static TypeScript file
```typescript
// src/content/site-config.ts
export const siteConfig: SiteConfig = {
  business: {
    name: "Ruby's Wine Shop",
    // ... static content
  }
}
```

**After**: Still a TypeScript file, but managed by Tina
```typescript
// src/content/site-config.ts
// Same structure, but can be edited via CMS
// Tina reads/writes to this file based on schema
```

### 4. Build Process

**Before**:
```bash
npm run dev     # → next dev
npm run build   # → next build
```

**After**:
```bash
npm run dev     # → tinacms dev -c "next dev"
npm run build   # → tinacms build && next build
```

### 5. Component Usage

**No Changes Required**: All React components continue importing from the same location:
```typescript
import { siteConfig } from '@/content/site-config';
```

This was a key design decision - the CMS integration is transparent to the rest of the application.

---

## How the CMS Integration Works

### High-Level Flow

```
┌─────────────────┐
│   Tina Admin    │ (Browser: /admin)
│   Interface     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Tina Backend   │ (API: /api/tina/*)
│  (Local/Cloud)  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Content File   │ (Filesystem: src/content/site-config.ts)
│  (TypeScript)   │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  React App      │ (Imports siteConfig)
│  Components     │
└─────────────────┘
```

### 1. Schema Definition (`.tina/config.ts`)

The schema defines the structure of content that can be edited:

```typescript
export default defineConfig({
  schema: {
    collections: [
      {
        name: "siteConfig",
        label: "Site Configuration",
        path: "src/content",
        format: "ts",
        fields: [
          // Field definitions matching SiteConfig type
        ]
      }
    ]
  }
})
```

**Key Features**:
- `format: "ts"` - Writes content as TypeScript
- `path: "src/content"` - Where files are stored
- `fields` - Matches the existing `SiteConfig` TypeScript interface
- `ui.allowedActions` - Prevents creating/deleting config (single file)

### 2. Database Client (`src/lib/tina.ts`)

Switches between local and cloud modes:

```typescript
const isLocal = process.env.TINA_PUBLIC_IS_LOCAL === "true";

const database = isLocal
  ? createLocalDatabase()      // Development: reads/writes files
  : createDatabase({           // Production: uses Tina Cloud
      clientId: process.env.NEXT_PUBLIC_TINA_CLIENT_ID!,
      token: process.env.TINA_TOKEN!,
    });
```

**Local Mode**:
- Reads/writes directly to filesystem
- No network requests to Tina Cloud
- Faster development cycle
- Changes appear immediately in git

**Cloud Mode**:
- Uses Tina Cloud's GraphQL API
- Syncs changes to GitHub
- Enables collaborative editing
- Required for production CMS access

### 3. API Routes (`src/app/api/tina/[...routes]/route.ts`)

Next.js API routes that handle Tina backend operations:

```typescript
const handler = TinaNodeBackend({
  authentication: isLocal
    ? LocalBackendAuthProvider()    // No auth in local mode
    : { authenticate: async () => true },  // Cloud auth
  databaseClient,
});

export const GET = async (request, context) => {
  return handler(request, context);
};

export const POST = async (request, context) => {
  return handler(request, context);
};
```

**Handles**:
- Content queries (GET)
- Content mutations (POST)
- Media uploads
- Authentication

### 4. Admin Interface (`src/app/admin/page.tsx`)

Simple redirect to the Tina admin UI:

```typescript
export default function AdminPage() {
  redirect("/admin/index.html");
}
```

The actual admin interface is built by `tinacms build` and placed in `public/admin/`.

### 5. Content Flow

**Reading Content**:
1. User visits `/admin`
2. Tina admin loads from `public/admin/index.html`
3. Admin fetches content via `/api/tina/*`
4. API routes query database client
5. Database reads `src/content/site-config.ts`
6. Content displayed in editor with live preview

**Writing Content**:
1. User edits fields in Tina admin
2. Clicks "Save"
3. Admin sends mutation to `/api/tina/*`
4. API routes update via database client
5. Database writes to `src/content/site-config.ts`
6. Git detects file change
7. User commits and pushes (or Tina Cloud auto-commits)

---

## Architecture Decisions

### 1. Git-Based Content Storage

**Decision**: Store content in git-tracked TypeScript files rather than a database.

**Rationale**:
- Version control for all content changes
- Easy rollback with git
- No separate database to manage
- Content lives with code
- Simpler deployment (no DB migrations)
- Better for small-to-medium sites

**Trade-offs**:
- ✅ Full version history
- ✅ Developer-friendly workflow
- ✅ No database costs
- ❌ Not ideal for thousands of content items
- ❌ Requires git knowledge for advanced operations

### 2. TypeScript for Content Format

**Decision**: Use TypeScript files (`.ts`) instead of Markdown or JSON.

**Rationale**:
- Type safety at build time
- Better IDE support (autocomplete, validation)
- Matches existing codebase patterns
- Compile-time error checking
- No runtime parsing needed

**Trade-offs**:
- ✅ Type-safe content
- ✅ Catches errors before deployment
- ✅ Better DX for developers
- ❌ Slightly less portable than JSON
- ❌ Requires TypeScript knowledge

### 3. Local-First Development

**Decision**: Enable local filesystem mode for development.

**Rationale**:
- Faster iteration (no network requests)
- Works offline
- Direct file manipulation
- Easier debugging
- Lower barrier to entry

**Trade-offs**:
- ✅ Fast development cycle
- ✅ No cloud dependency for local dev
- ✅ Changes immediately visible in git
- ⚠️ Requires mode switching for production testing
- ⚠️ Local and cloud modes behave slightly differently

### 4. Single Configuration File

**Decision**: Use one file for all site content instead of multiple collections.

**Rationale**:
- Simpler mental model for small site
- All content in one place
- Matches original static config approach
- Easier to maintain consistency
- Atomic commits for related changes

**Trade-offs**:
- ✅ Simple structure
- ✅ Easy to find content
- ✅ Consistent with original design
- ❌ Large file (but manageable for this site)
- ❌ All content locked during edits (not an issue for single user)

### 5. Visual Editing in Admin UI

**Decision**: Use Tina's admin interface instead of inline editing.

**Rationale**:
- Clear separation between editing and viewing
- Dedicated editing environment
- Better for structured content
- Easier to manage complex nested data
- Preview pane shows changes

**Trade-offs**:
- ✅ Clean separation of concerns
- ✅ Better for complex forms
- ✅ Familiar CMS-like experience
- ❌ Not WYSIWYG editing on live page
- ❌ Requires navigating to `/admin`

### 6. No Authentication in Local Mode

**Decision**: Disable authentication for local development.

**Rationale**:
- Local development is already authenticated (local filesystem)
- Simpler setup for developers
- No need for auth tokens locally
- Faster development

**Trade-offs**:
- ✅ Simpler local setup
- ✅ No auth configuration needed
- ⚠️ Production must use proper auth
- ⚠️ `/admin` is publicly accessible in local mode (localhost only)

---

## Migration from Static Config to Tina

### Pre-Migration State

The site was fully functional with static TypeScript configuration:

```typescript
// src/content/site-config.ts
export const siteConfig: SiteConfig = {
  business: { /* ... */ },
  hero: { /* ... */ },
  // ... all sections
};
```

All components imported this directly:
```typescript
import { siteConfig } from '@/content/site-config';
```

### Migration Steps

#### 1. Install Dependencies

```bash
npm install tinacms @tinacms/cli
```

#### 2. Create Tina Configuration

Create `.tina/config.ts` with schema matching the existing `SiteConfig` TypeScript interface.

**Key Mapping**:
- TypeScript interfaces → Tina field types
- Nested objects → Tina object fields
- Arrays → Tina list fields
- Enums → Tina select/options fields
- Images → Tina image fields

#### 3. Create Database Client

Create `src/lib/tina.ts` to handle local vs. cloud mode:

```typescript
const database = isLocal
  ? createLocalDatabase()
  : createDatabase({ clientId, token });
```

#### 4. Add API Routes

Create `src/app/api/tina/[...routes]/route.ts` for backend:

```typescript
const handler = TinaNodeBackend({
  authentication: /* ... */,
  databaseClient,
});
```

#### 5. Create Admin Page

Create `src/app/admin/page.tsx`:

```typescript
redirect("/admin/index.html");
```

#### 6. Update Build Scripts

Update `package.json`:

```json
{
  "scripts": {
    "dev": "tinacms dev -c \"next dev\"",
    "build": "tinacms build && next build"
  }
}
```

#### 7. Configure Environment Variables

Create `.env.local` with Tina credentials.

#### 8. Test Locally

```bash
npm run dev
# Visit http://localhost:3000/admin
# Edit content and verify changes
```

#### 9. Verify No Breaking Changes

All existing imports still work:
```typescript
import { siteConfig } from '@/content/site-config';
```

The file structure remains the same, just now manageable via CMS.

### Migration Challenges & Solutions

**Challenge 1: TypeScript Formatting**

Tina writes TypeScript, but formatting may differ from Prettier/ESLint.

**Solution**: Run Prettier after Tina updates:
```bash
# Can be automated in git hooks
npx prettier --write src/content/site-config.ts
```

**Challenge 2: Complex Nested Data**

The schema has deeply nested objects (menu categories, events, etc.).

**Solution**: Use Tina's object and list field types with proper labels for clarity.

**Challenge 3: Image Paths**

Images need correct paths (`/images/...`) to work with Next.js Image component.

**Solution**: Configure Tina media to use `public/images/` and ensure paths start with `/images/`.

**Challenge 4: Type Safety**

Need to ensure Tina schema matches TypeScript interfaces.

**Solution**: Manually keep `.tina/config.ts` fields in sync with `src/types/content.ts`. Consider code generation in future.

---

## Technical Implementation Details

### Tina Schema Configuration

The `.tina/config.ts` file is the heart of the CMS integration.

#### Collection Configuration

```typescript
{
  name: "siteConfig",
  label: "Site Configuration",
  path: "src/content",
  format: "ts",
  ui: {
    allowedActions: {
      create: false,  // Prevent creating new configs
      delete: false,  // Prevent deleting the config
    },
    router: () => "/",  // Preview shows homepage
  },
  match: {
    include: "site-config",  // Only match site-config.ts
  },
  fields: [ /* ... */ ]
}
```

#### Field Types Used

| Tina Type | TypeScript Type | Usage |
|-----------|-----------------|-------|
| `string` | `string` | Text fields (names, titles) |
| `number` | `number` | Coordinates, prices |
| `boolean` | `boolean` | Flags (recurring events) |
| `image` | `string` | Image paths |
| `object` | `interface` | Nested data structures |
| `list: true` | `Array<T>` | Arrays (events, FAQs, menu items) |
| `options` | `union type` | Enums (CTA actions) |

#### Example Field Configuration

```typescript
{
  type: "object",
  name: "menu",
  label: "Menu Section",
  fields: [
    {
      type: "string",
      name: "heading",
      label: "Main Heading",
      required: true,
    },
    {
      type: "object",
      name: "byTheGlass",
      label: "By the Glass",
      fields: [
        {
          type: "object",
          name: "items",
          label: "Glass Wines",
          list: true,  // Array of wine items
          fields: [
            { type: "string", name: "name", required: true },
            { type: "string", name: "price", required: true },
            // ... more fields
          ]
        }
      ]
    }
  ]
}
```

### Environment Configuration

#### Development (`.env.local`)

```bash
NEXT_PUBLIC_TINA_CLIENT_ID=abc123
TINA_TOKEN=def456
NEXT_PUBLIC_TINA_BRANCH=main
TINA_PUBLIC_IS_LOCAL=true  # Use filesystem
```

#### Production (Vercel)

```bash
NEXT_PUBLIC_TINA_CLIENT_ID=abc123
TINA_TOKEN=ghi789
NEXT_PUBLIC_TINA_BRANCH=main
# TINA_PUBLIC_IS_LOCAL not set (uses cloud mode)
```

### Build Process

#### Development Build

```bash
npm run dev
# ↓
tinacms dev -c "next dev"
# ↓
# 1. Tina watches .tina/config.ts for changes
# 2. Generates GraphQL schema in .tina/__generated__/
# 3. Starts Next.js dev server
# 4. Admin UI available at /admin
```

#### Production Build

```bash
npm run build
# ↓
tinacms build && next build
# ↓
# 1. Tina builds admin UI → public/admin/
# 2. Generates types and schema
# 3. Next.js builds production bundle
# 4. Static admin UI served from /admin
```

### Media Management

#### Configuration

```typescript
media: {
  tina: {
    mediaRoot: "images",        // Root folder for images
    publicFolder: "public",     // Public directory
  },
}
```

#### Upload Flow

1. User clicks image field in admin
2. Selects file from computer
3. Tina uploads to `public/images/`
4. Returns path: `/images/filename.jpg`
5. Path saved in content file

#### Image Paths

All images referenced as:
```typescript
hero: {
  images: {
    desktop: "/images/hero-desktop.jpg",  // Absolute path from public/
    mobile: "/images/hero-mobile.jpg",
  }
}
```

Used in components with Next.js Image:
```tsx
<Image src={hero.images.desktop} alt={hero.images.alt} />
```

---

## Future Improvements

### 1. Content Validation

**Current State**: Basic required field validation in Tina schema.

**Improvements**:
- Custom validation for email format
- Phone number format validation
- URL validation for external links
- Price format validation ($XX.XX)
- Coordinate bounds checking (lat/lng)

**Implementation**:
```typescript
{
  type: "string",
  name: "email",
  ui: {
    validate: (value) => {
      if (!value.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
        return "Please enter a valid email address";
      }
    }
  }
}
```

### 2. Rich Text Editing

**Current State**: Plain text fields with `textarea` component.

**Improvements**:
- Markdown support for descriptions
- Rich text editor for story paragraphs
- Basic formatting (bold, italic, links)
- Bullet points for lists

**Implementation**:
```typescript
{
  type: "rich-text",  // Instead of string
  name: "description",
  label: "Description",
}
```

**Benefits**:
- Better content formatting
- Preserve line breaks
- Add emphasis where needed
- Link to external resources

### 3. Image Optimization Automation

**Current State**: Manual image optimization before upload.

**Improvements**:
- Automatic image resizing on upload
- WebP conversion
- Responsive image variants
- Compression optimization
- Image CDN integration

**Implementation**:
```typescript
media: {
  tina: {
    mediaRoot: "images",
    publicFolder: "public",
    // Add image processing
    imageOptimization: {
      enabled: true,
      formats: ["webp", "jpg"],
      sizes: [400, 800, 1200, 1920],
    }
  }
}
```

### 4. Content Previews

**Current State**: Preview pane in admin interface.

**Improvements**:
- Better mobile preview
- Multiple device sizes (phone, tablet, desktop)
- Dark mode preview
- Print preview
- Share preview links

**Implementation**:
- Use Tina's iframe preview with responsive toggles
- Add custom toolbar for device switching
- Generate preview URLs for stakeholders

### 5. Scheduled Publishing

**Current State**: Changes publish immediately on save.

**Improvements**:
- Schedule content changes for future dates
- Draft/published states
- Content versioning
- Rollback to previous versions

**Implementation**:
- Add `publishedAt` field to content
- Filter content by date in components
- Use Vercel Cron or GitHub Actions for scheduled deployments

### 6. Multi-Language Support

**Current State**: English only.

**Improvements**:
- Internationalization (i18n)
- Multiple language versions
- Language switcher
- Translate all content fields

**Implementation**:
```typescript
collections: [
  {
    name: "siteConfig",
    fields: [
      {
        name: "locale",
        type: "string",
        options: ["en", "de", "fr"],  // English, German, French
      },
      // ... rest of fields
    ]
  }
]
```

### 7. Analytics Integration

**Current State**: No analytics in CMS.

**Improvements**:
- Track popular content
- View engagement metrics
- A/B testing for headlines
- Click tracking for CTAs

**Implementation**:
- Integrate Google Analytics or Plausible
- Add event tracking to CMS
- Dashboard showing content performance
- Suggest optimizations based on data

### 8. SEO Enhancements

**Current State**: Basic SEO fields (title, description, OG image).

**Improvements**:
- SEO score/analysis in editor
- Keyword suggestions
- Character count helpers
- Preview for Google search results
- Social media preview cards
- Structured data validation

**Implementation**:
- Add Yoast-style SEO analysis
- Character counters with warnings
- Live preview of search result appearance
- Schema.org validation

### 9. Content Templates

**Current State**: Manual entry for all content.

**Improvements**:
- Templates for common content types
- Quick-add buttons for menu items
- Duplicate event functionality
- Import/export content

**Implementation**:
```typescript
ui: {
  presets: [
    {
      label: "Red Wine Template",
      fields: {
        price: "$XX",
        description: "Rich and full-bodied...",
      }
    }
  ]
}
```

### 10. Workflow Improvements

**Current State**: Single-user editing.

**Improvements**:
- Multi-user editing with roles
- Editor vs. Admin permissions
- Content approval workflow
- Edit history and audit log
- Comments on content changes

**Implementation**:
- Use Tina Cloud's user management
- Define roles in Tina config
- Approval gates before publishing
- Activity log for all changes

### 11. Performance Monitoring

**Current State**: No CMS performance tracking.

**Improvements**:
- Track save times
- Monitor build performance
- Alert on slow queries
- Optimize large content files

**Implementation**:
- Add logging to API routes
- Monitor Tina Cloud API response times
- Use Vercel Analytics for build times
- Consider splitting large configs if needed

### 12. Backup and Recovery

**Current State**: Git history provides backups.

**Improvements**:
- Automated backups to cloud storage
- One-click content restore
- Export content to JSON
- Import from external sources

**Implementation**:
```bash
# Automated backup script
npm run backup-content
# → Saves site-config.ts to S3/Dropbox with timestamp
```

### 13. Enhanced Media Library

**Current State**: Simple file browser for images.

**Improvements**:
- Image search and filtering
- Tags and categories for images
- Image metadata (alt text, captions)
- Bulk upload
- Image history and versions
- Unused image detection

**Implementation**:
- Use Tina's media store features
- Add custom metadata fields
- Create media management dashboard
- Integrate with Cloudinary or similar

### 14. Type Generation

**Current State**: Manual sync between Tina schema and TypeScript types.

**Improvements**:
- Auto-generate TypeScript types from Tina schema
- Ensure type safety between CMS and code
- Automated type checking in CI

**Implementation**:
```bash
# Generate types from schema
tinacms schema
# → Outputs types to src/types/tina.d.ts
```

### 15. Better Developer Experience

**Current State**: Basic documentation.

**Improvements**:
- Inline documentation in schema
- Field descriptions and hints
- Example content in placeholders
- Video tutorials for editors
- Interactive onboarding

**Implementation**:
```typescript
{
  type: "string",
  name: "tagline",
  label: "Tagline",
  description: "A short, catchy phrase describing your business (max 60 characters)",
  ui: {
    component: "textarea",
    placeholder: "e.g., Natural wines & good vibes in Albion",
  }
}
```

---

## Performance Considerations

### Current Performance

- **Build Time**: ~30-60 seconds (Tina build + Next.js build)
- **Admin Load Time**: < 2 seconds
- **Save Operations**: < 1 second (local mode)
- **Preview Update**: Real-time

### Optimization Strategies

1. **Code Splitting**: Tina admin is separate bundle (not in main app)
2. **Lazy Loading**: Admin UI loads only when visiting `/admin`
3. **Incremental Builds**: Next.js only rebuilds changed pages
4. **Static Generation**: Content is static, no runtime database queries
5. **CDN Caching**: Static admin UI cached at edge

### Monitoring

- Use Vercel Analytics to track build times
- Monitor Core Web Vitals for admin interface
- Track save operation latency
- Check bundle sizes regularly

---

## Security Considerations

### Content Security

- **Environment Variables**: `TINA_TOKEN` is server-side only (not exposed to browser)
- **API Routes**: Protected by Tina authentication in production
- **Local Mode**: No authentication (localhost only, not production)
- **Cloud Mode**: Uses Tina Cloud auth with tokens

### Best Practices

1. **Separate Tokens**: Use different tokens for dev and production
2. **Token Rotation**: Regenerate tokens periodically
3. **Git Secrets**: Never commit `.env.local` or tokens to git
4. **Access Control**: Limit who has Tina Cloud access
5. **Branch Protection**: Require PR reviews for content changes (optional)

### Production Deployment

- Set environment variables in Vercel dashboard
- Ensure `TINA_PUBLIC_IS_LOCAL` is not set (or `false`)
- Verify authentication works before making site public
- Consider adding custom auth to `/admin` route if needed

---

## Maintenance and Updates

### Regular Tasks

**Weekly**:
- Review content changes in git history
- Check for any failed deployments
- Monitor Tina Cloud usage (if applicable)

**Monthly**:
- Update Tina CMS dependencies
- Review and test new Tina features
- Check for security updates

**Quarterly**:
- Audit content structure for improvements
- Review analytics to optimize content
- Gather user feedback on CMS experience

### Updating Tina CMS

```bash
# Check for updates
npm outdated tinacms @tinacms/cli

# Update to latest
npm update tinacms @tinacms/cli

# Test thoroughly
npm run dev
# Visit /admin and test all features
npm run build
```

### Schema Updates

When adding new fields to the schema:

1. Update `.tina/config.ts` with new fields
2. Update `src/types/content.ts` TypeScript interface
3. Update components that use the new fields
4. Test in local mode
5. Verify build succeeds
6. Document changes

---

## Conclusion

The Tina CMS integration successfully provides a user-friendly editing interface while maintaining the benefits of a git-based, TypeScript workflow. The implementation is:

- **Type-safe**: Content structure validated at compile-time
- **Version-controlled**: All changes tracked in git
- **Performant**: No runtime overhead for frontend
- **Flexible**: Easy to add new fields and sections
- **Developer-friendly**: Familiar TypeScript/React patterns
- **User-friendly**: Visual editing for non-technical users

### Key Takeaways

1. **Git-based CMS**: Best for small-to-medium sites with developer involvement
2. **TypeScript Format**: Provides type safety and better DX
3. **Local-First**: Enables fast development without cloud dependency
4. **Schema-Driven**: Content structure defined in code, ensuring consistency
5. **Incremental Adoption**: CMS integrated without rewriting existing code

### Resources

- **Tina Documentation**: https://tina.io/docs/
- **GitHub Repository**: (your repo URL)
- **Vercel Dashboard**: https://vercel.com
- **Tina Cloud**: https://app.tina.io

---

**Last Updated**: February 2026

For questions about this implementation, contact the development team.
